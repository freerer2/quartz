---
date: 2024-1-5
updated: 2024-1-5
order: 30
---
## 생성자 정의하기

클래스에는 클래스 블루프린트에서 객체를 생성하기 위해 호출되는 생성자가 포함됩니다. 생성자 선언은 클래스 이름을 사용하고 반환 타입이 없다는 점을 제외하면 메서드 선언과 비슷합니다. 예를 들어 `Bicycle`에는 생성자가 하나 있습니다:

```java
public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}
```

`myBike`라는 새로운 `Bicycle` 객체를 생성하려면 `new` 연산자가 생성자를 호출합니다:

```java
Bicycle myBike = new Bicycle(30, 0, 8);
```

`new Bicycle(30, 0, 8)` 코드는 메모리에 객체를 위한 공간을 생성하고 필드를 초기화합니다.

`Bicycle`에는 생성자가 하나만 있지만 인수가 없는 생성자 등 다른 생성자가 있을 수 있습니다:

```java
public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}
```

`Bicycle yourBike = new Bicycle();` 코드는 인수가 없는 생성자를 호출하여 `yourBike`라는 새 `Bicycle` 객체를 생성합니다.

두 생성자 모두 인자 목록이 다르기 때문에 `Bicycle`으로 선언할 수 있습니다. 메서드와 마찬가지로 Java 플랫폼은 목록의 인자 수와 인자의 타입에 따라 생성자를 구분합니다. 컴파일러가 이를 구분할 수 없기 때문에 같은 클래스에 대해 인수의 수와 타입이 같은 생성자를 두 개 작성할 수 없습니다. 그렇게 하면 컴파일 타임 오류가 발생합니다.

클래스에 생성자를 제공하지 않아도 되지만 이 경우 주의해야 합니다. 컴파일러는 생성자가 없는 모든 클래스에 대해 인수가 없는 기본 생성자를 자동으로 제공합니다. 이 기본 생성자는 수퍼클래스의 인자 없는 생성자를 호출합니다. 이 경우 컴파일러는 슈퍼클래스에 인자 없는 생성자가 없는 경우 컴파일러가 경고하므로 인자 없는 생성자가 있는지 확인해야 합니다. 클래스에 명시적 수퍼클래스가 없는 경우, 인자 없는 생성자가 있는 암시적 수퍼클래스인 `Object`가 있습니다.

수퍼클래스 생성자를 직접 사용할 수 있습니다. 이 강의의 시작 부분에 있는 `MountainBike` 클래스가 바로 그렇게 했습니다. 이에 대해서는 나중에 인터페이스와 상속 단원에서 설명하겠습니다.

생성자 선언에서 접근 수정자를 사용하여 생성자를 호출할 수 있는 다른 클래스를 제어할 수 있습니다.
