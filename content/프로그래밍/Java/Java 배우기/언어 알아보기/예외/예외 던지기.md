---
order: 30
---
## 메서드가 던지는 예외 지정하기

이전 섹션에서는 `ListOfNumbers` 클래스의 `writeList()` 메서드에 대한 예외 핸들러를 작성하는 방법을 살펴봤습니다. 때로는 코드 내에서 발생할 수 있는 예외를 코드가 직접 잡는 것이 적절할 수 있습니다. 그러나 다른 경우에는 호출 스택의 더 위쪽에 있는 메서드가 예외를 처리하도록 하는 것이 더 좋습니다. 예를 들어, 클래스 패키지의 일부로 `ListOfNumbers` 클래스를 제공하는 경우 패키지의 모든 사용자의 요구를 예상할 수 없을 수 있습니다. 이 경우 예외를 catch하지 않고 호출 스택의 상위 메서드가 예외를 처리하도록 허용하는 것이 좋습니다.

`writeList()` 메서드가 그 안에서 발생할 수 있는 checked exceptions을 catch하지 않는다면, `writeList()` 메서드는 이러한 예외를 던질 수 있도록 지정해야 합니다. 예외를 catch하는 대신 던질 수 있는 예외를 지정하도록 원래의 `writeList()` 메서드를 수정해 보겠습니다. 참고로 컴파일되지 않는 `writeList()` 메서드의 원래 버전은 다음과 같습니다.

```java
public void writeList() {
    PrintWriter out = new PrintWriter(new FileWriter("OutFile.txt"));
    for (int i = 0; i < SIZE; i++) {
        out.println("Value at: " + i + " = " + list.get(i));
    }
    out.close();
}
```

`writeList()`가 두 가지 예외를 던질 수 있도록 지정하려면 `writeList()` 메서드 선언에 throws 절을 추가합니다. `throws` 절은 `throws` 키워드와 그 뒤에 쉼표로 구분된 해당 메서드가 던지는 모든 예외의 목록으로 구성됩니다. 이 절은 메서드 이름과 인수 목록 뒤와 메서드의 범위를 정의하는 중괄호 앞에 오며, 다음은 예시입니다.

```java
public void writeList() throws IOException, IndexOutOfBoundsException {
```

[`IndexOutOfBoundsException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/IndexOutOfBoundsException.html)은 체크되지 않은 예외이므로 `throws` 절에 포함시키는 것은 필수가 아닙니다. 다음과 같이 작성할 수 있습니다.

```java
public void writeList() throws IOException {
```

 

## 예외를 던지는 방법

예외를 잡으려면 먼저 어딘가에서 예외를 던지는 코드가 있어야 합니다. 내 코드, Java 플랫폼과 함께 제공되는 패키지와 같은 다른 사람이 작성한 패키지의 코드 또는 Java 런타임 환경 등 모든 코드가 예외를 던질 수 있습니다. 예외를 던지는 것이 무엇이든 예외는 항상 `throw` 문과 함께 던져집니다.

이미 알고 계시겠지만, Java 플랫폼은 수많은 예외 클래스를 제공합니다. 모든 클래스는 [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스의 하위 클래스이며, 모두 프로그램 실행 중에 발생할 수 있는 다양한 타입의 예외를 구분할 수 있게 해줍니다.

작성한 클래스 내에서 발생할 수 있는 문제를 나타내는 자체 예외 클래스를 만들 수도 있습니다. 실제로 패키지 개발자의 경우 사용자가 패키지에서 발생할 수 있는 오류를 Java 플랫폼이나 다른 패키지에서 발생하는 오류와 구분할 수 있도록 자체 예외 클래스 집합을 만들어야 할 수도 있습니다.

연쇄 예외를 만들 수도 있습니다. 자세한 내용은 연쇄 예외 섹션을 참조하세요.

 

## Throw 명령문

모든 메서드는 `throw` 문을 사용하여 예외를 던집니다. `throw` 문은 하나의 인자, 즉 throw 가능한 객체를 필요로 합니다. Throw 가능 객체는 [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스의 모든 서브클래스의 인스턴스입니다. 다음은 `throw` 문의 예입니다.

```java
throw someThrowableObject;
```

문맥에서 `throw` 문을 살펴봅시다. 다음 `pop()` 메서드는 일반적인 스택 객체를 구현하는 클래스에서 가져온 것입니다. 이 메서드는 스택에서 최상위 요소를 제거하고 객체를 반환합니다.

```java
public Object pop() {
    Object obj;

    if (size == 0) {
        throw new EmptyStackException();
    }

    obj = objectAt(size - 1);
    setObjectAt(size - 1, null);
    size--;
    return obj;
}
```

`pop()` 메서드는 스택에 요소가 있는지 확인합니다. 스택이 비어 있으면(크기가 0과 같으면), pop은 [`java.util`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/package-summary.html)의 멤버인 새로운 [`EmptyStackException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/EmptyStackException.html) 객체를 인스턴스화하여 이를 던집니다. 이 장의 예외 클래스 생성하기 섹션에서는 자신만의 예외 클래스를 만드는 방법을 설명합니다. 지금은 [`java.lang.Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스에서 상속하는 객체만 던질 수 있다는 점만 기억하면 됩니다.

`pop()` 메서드의 선언에는 `throws` 절이 포함되어 있지 않다는 점에 유의하세요. [`EmptyStackException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/EmptyStackException.html)은 검사대상이 되는 예외가 아니므로 팝은 예외가 발생할 수 있음을 명시할 필요가 없습니다.

 

## Throw 가능 클래스와 그 서브클래스

[`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스로부터 상속하는 객체에는 직접 자손([`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스로부터 직접 상속하는 객체)과 간접 자손([`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스의 자식이나 손자로부터 상속하는 객체)이 있습니다. 아래 그림은 [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 클래스와 그 주요 서브클래스의 클래스 계층구조를 보여줍니다. 보시다시피, [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html)에는 두 개의 직계 자손이 있습니다: [`Error`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Error.html)와 [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html).

![The Throwable hierarchy](https://dev.java/assets/images/exceptions/throwable-hierarchy.png)

Throwable 계층구조

 

## Error Class

Java 가상 머신에서 동적 연결 실패 또는 기타 하드 장애가 발생하면 가상 머신은 [`Error`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Error.html)를 던집니다. 간단한 프로그램은 일반적으로 [`Error`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Error.html) 인스턴스를 캐치하거나 던지지 않습니다.

 

## Exception Class

대부분의 프로그램은 [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) 클래스에서 파생된 객체를 던지고 잡습니다. [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html)은 문제가 발생했지만 심각한 시스템 문제는 아님을 나타냅니다. 여러분이 작성하는 대부분의 프로그램은 [`Error`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Error.html)와 달리 [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html)의 인스턴스를 던지고 잡습니다.

Java 플랫폼은 [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) 클래스의 많은 자손을 정의합니다. 이러한 자손은 발생할 수 있는 다양한 타입의 예외를 나타냅니다. 예를 들어, [`IllegalAccessException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/IllegalAccessException.html)은 특정 메서드를 찾을 수 없음을 알리고, [`NegativeArraySizeException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/NegativeArraySizeException.html)은 프로그램이 음수 크기의 배열을 만들려고 시도했음을 나타냅니다.

하나의 [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) 서브클래스인 [`RuntimeException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/RuntimeException.html)은 API의 잘못된 사용을 나타내는 예외를 위해 예약되어 있습니다. 런타임 예외의 예로는 메서드가 널 참조를 통해 객체의 멤버에 액세스하려고 시도할 때 발생하는 [`NullPointerException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/NullPointerException.html)이 있습니다. [[확인되지 않은 예외]] 섹션에서는 대부분의 애플리케이션이 런타임 예외 또는 [`RuntimeException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/RuntimeException.html)의 하위 클래스를 던져서는 안 되는 이유에 대해 설명합니다.

 

## 연쇄 예외

애플리케이션은 종종 다른 예외를 던져서 예외에 응답합니다. 사실상 첫 번째 예외가 두 번째 예외를 유발하는 것입니다. 하나의 예외가 다른 예외를 유발하는 경우를 파악하는 것은 매우 유용할 수 있습니다. 연쇄 예외는 프로그래머가 이 작업을 수행하는 데 도움이 됩니다.

다음은 연쇄 예외를 지원하는 [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html)의 메서드와 생성자입니다.

```java
Throwable getCause()
Throwable initCause(Throwable)
Throwable(String, Throwable)
Throwable(Throwable)
```

[`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 인수는 `initCause()`와 [`Throwable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html) 생성자의 현재 예외를 발생시킨 예외입니다. [`getCause()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html#getCause())는 현재 예외를 발생시킨 예외를 반환하고 `initCause()`는 현재 예외의 원인을 설정합니다.

다음 예제는 연쇄 예외를 사용하는 방법을 보여줍니다.

```java
try {

} catch (IOException e) {
    throw new SampleException("Other IOException", e);
}
```

In this example, when an [`IOException`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/io/IOException.html) is caught, a new `SampleException` exception is created with the original cause attached and the chain of exceptions is thrown up to the next higher level exception handler.

 

## Accessing Stack Trace Information

Now let's suppose that the higher-level exception handler wants to dump the stack trace in its own format.

> Definition: A stack trace provides information on the execution history of the current thread and lists the names of the classes and methods that were called at the point when the exception occurred. A stack trace is a useful debugging tool that you'll normally take advantage of when an exception has been thrown.

The following code shows how to call the [`getStackTrace()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Throwable.html#getStackTrace()) method on the exception object.

```java
catch (Exception cause) {
    StackTraceElement elements[] = cause.getStackTrace();
    for (int i = 0, n = elements.length; i < n; i++) {       
        System.err.println(elements[i].getFileName()
            + ":" + elements[i].getLineNumber() 
            + ">> "
            + elements[i].getMethodName() + "()");
    }
}
```

### Logging API

The next code snippet logs where an exception occurred from within the `catch` block. However, rather than manually parsing the stack trace and sending the output to [`java.util.logging`](https://docs.oracle.com/en/java/javase/22/docs/api/java.logging/java/util/logging/package-summary.html), it sends the output to a file using the logging facility in the [`java.util.logging`](https://docs.oracle.com/en/java/javase/22/docs/api/java.logging/java/util/logging/package-summary.html) package.

```java
try {
    Handler handler = new FileHandler("OutFile.log");
    Logger.getLogger("").addHandler(handler);
    
} catch (IOException e) {
    Logger logger = Logger.getLogger("package.name"); 
    StackTraceElement elements[] = e.getStackTrace();
    for (int i = 0, n = elements.length; i < n; i++) {
        logger.log(Level.WARNING, elements[i].getMethodName());
    }
}
```

 

## Creating Exception Classes

When faced with choosing the type of exception to throw, you can either use one written by someone else — the Java platform provides a lot of exception classes you can use — or you can write one of your own. You should write your own exception classes if you answer yes to any of the following questions; otherwise, you can probably use someone else's.

- Do you need an exception type that isn't represented by those in the Java platform?
- Would it help users if they could differentiate your exceptions from those thrown by classes written by other vendors?
- Does your code throw more than one related exception?
- If you use someone else's exceptions, will users have access to those exceptions? A similar question is, should your package be independent and self-contained?

### An Example

Suppose you are writing a linked list class. The class supports the following methods, among others:

- `objectAt(int n)` — Returns the object in the nth position in the list. Throws an exception if the argument is less than 0 or more than the number of objects currently in the list.
- `firstObject()` — Returns the first object in the list. Throws an exception if the list contains no objects.
- `indexOf(Object o)` — Searches the list for the specified Object and returns its position in the list. Throws an exception if the object passed into the method is not in the list.

The linked list class can throw multiple exceptions, and it would be convenient to be able to catch all exceptions thrown by the linked list with one exception handler. Also, if you plan to distribute your linked list in a package, all related code should be packaged together. Thus, the linked list should provide its own set of exception classes.

The next figure illustrates one possible class hierarchy for the exceptions thrown by the linked list.

![Example exception class hierarchy](https://dev.java/assets/images/exceptions/linkedlist-exceptions.png)

Example exception class hierarchy

### Choosing a Superclass

Any [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) subclass can be used as the parent class of `LinkedListException`. However, a quick perusal of those subclasses shows that they are inappropriate because they are either too specialized or completely unrelated to `LinkedListException`. Therefore, the parent class of `LinkedListException` should be Exception.

Most applications you write will throw objects that are instances of [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html). Instances of [`Error`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Error.html) are normally used for serious, hard errors in the system, such as those that prevent the JVM from running.

Note: For readable code, it's good practice to append the string [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) to the names of all classes that inherit (directly or indirectly) from the [`Exception`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Exception.html) class.

---
Last update: September 14, 2021