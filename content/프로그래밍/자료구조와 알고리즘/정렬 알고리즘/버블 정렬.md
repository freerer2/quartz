---
date: 2024-07-02
updated: 2024-07-02
order: 20
---
버블 정렬은 이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘입니다.

## 버블 정렬 알아보기

배열을 통해 버블 정렬을 알아봅니다.

| index |  0  |  1  |  2  |  3  |  4  |   5   |   6   |
| :---: | :-: | :-: | :-: | :-: | :-: | :---: | :---: |
| value |  6  |  4  |  3  |  7  |  1  | ==9== | ==8== |

끝에 있는 두 요소부터 시작합니다. 배열이 오름차순이라면 왼쪽 값이 오른쪽 값보다 작아야 합니다. 따라서 9와 8을 교환한 배열은 다음과 같습니다:

| index |  0  |  1  |  2  |  3  |   4   |   5   |  6  |
| :---: | :-: | :-: | :-: | :-: | :---: | :---: | :-: |
| value |  6  |  4  |  3  |  7  | ==1== | ==8== |  9  |

그 다음 1과 8을 비교합니다. 1은 8보다 작으므로 교환하지 않습니다. 이 과정을 요소수가 n개인 배열에서 n-1번 비교, 교환 하고 나면 가장 작은 요소가 맨 처음으로 이동하며 이 과정(비교, 교환)을 패스라고 합니다. 

| 시작  |   6   |   4   |   3   |   7   |   1   | ==9== | ==8== |
| :-: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 2차  |   6   |   4   |   3   |   7   | ==1== | ==8== |   9   |
| 3차  |   6   |   4   |   3   | ==7== | ==1== |   8   |   9   |
| 4차  |   6   |   4   | ==3== | ==1== |   7   |   8   |   9   |
| 5차  |   6   | ==4== | ==1== |   3   |   7   |   8   |   9   |
| 6차  | ==6== | ==1== |   4   |   3   |   7   |   8   |   9   |
| 종료  |   1   |   6   |   4   |   3   |   7   |   8   |   9   |

이어서 두 번째 이후 요소를 비교, 교환하는 패스를 수행합니다.

| 시작  | ~~1~~ |   6   |   4   |   3   |   7   | ==8== | ==9== |
| :-: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 2차  | ~~1~~ |   6   |   4   |   3   | ==7== | ==8== |   9   |
| 3차  | ~~1~~ |   6   |   4   | ==3== | ==7== |   8   |   9   |
| 4차  | ~~1~~ |   6   | ==4== | ==3== |   7   |   8   |   9   |
| 5차  | ~~1~~ | ==6== | ==3== |   4   |   7   |   8   |   9   |
| 종료  | ~~1~~ |   3   |   6   |   3   |   7   |   8   |   9   |

이 패스를 수행하면 두 번째 작은 수인 3은 두 번째 자리로 이동합니다.

다음은 위 내용을 바탕으로 작성한 버블 정렬 프로그램입니다:

```java
//--- 버블 정렬 ---//
static void bubbleSort(int[] a, int n) {
	for (int i = 0; i < n - 1; i++) {
		for (int j = n - 1; j > i; j--) {
			if (a[j - 1] > a[j]) { //왼쪽의 값이 더 크다면
				int t = a[j - 1]; //왼쪽 값을 임시값에 대입한 뒤
				a[j - 1] = a[j]; //오른쪽 값을 왼쪽 값에 대입하고
				a[j] = t; //임시값을 오른쪽 값에 대입한다
			}
		}
	}
}
```

서로 이웃한 요소만 교환하므로 이 정렬 알고리즘은 안정적이라고 할 수 있습니다. 첫 번째 패스의 비교횟수는 n-1회, 두번째는 n-2회 이므로  비교 횟수는 $$n(n-1)/2$$회 입니다.

교환 횟수의 평균값은 비교 횟수의 절반인 $$n(n-1)/4$$
회 입니다.

값의 이동 횟수의 평균값은 교환을 위해 3번 움직이므로 $$3n(n-1)/4$$회 입니다.

### 알고리즘 개선하기1

