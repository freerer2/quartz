## 타입 추론과 제네릭 메서드

_타입 추론_ 은 각 메서드 호출과 해당 선언을 살펴보고 해당 호출을 적용할 수 있는 타입 인자(또는 인수)를 결정하는 Java 컴파일러의 기능입니다. 추론 알고리즘은 인수의 타입과 가능한 경우 결과가 할당되거나 반환되는 타입을 결정합니다. 마지막으로 추론 알고리즘은 모든 인수를 사용할 수 있는 가장 구체적인 타입을 찾으려고 시도합니다.

이 마지막 요점을 설명하기 위해 다음 예제에서는 추론을 통해 선택 메서드에 전달되는 두 번째 인수가 [`Serializable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/io/Serializable.html) 타입임을 확인합니다:

```java
static <T> T pick(T a1, T a2) { return a2; }
Serializable s = pick("d", new ArrayList<String>());
```

제네릭 메서드에서는 일반 메서드처럼 꺾쇠 괄호 사이에 타입을 지정하지 않고도 제네릭 메서드를 호출할 수 있는 타입 추론에 대해 소개했습니다. `Box` 클래스가 필요한 다음 예제인 `BoxDemo`를 살펴보겠습니다:

```java
public class BoxDemo {

  public static <U> void addBox(U u, 
      java.util.List<Box<U>> boxes) {
    Box<U> box = new Box<>();
    box.set(u);
    boxes.add(box);
  }

  public static <U> void outputBoxes(java.util.List<Box<U>> boxes) {
    int counter = 0;
    for (Box<U> box: boxes) {
      U boxContents = box.get();
      System.out.println("Box #" + counter + " contains [" +
             boxContents.toString() + "]");
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList<Box<Integer>> listOfIntegerBoxes =
      new java.util.ArrayList<>();
    BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
```

다음은 이 예제의 출력입니다:

```shell
Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
```

제네릭 메서드 `addBox()`는 `U`라는 하나의 타입 매개변수를 정의합니다. 일반적으로 Java 컴파일러는 제네릭 메서드 호출의 타입 매개변수를 유추할 수 있습니다. 따라서 대부분의 경우 유형 매개변수를 지정할 필요가 없습니다. 예를 들어, 제네릭 메서드 `addBox()`를 호출하려면 다음과 같이 타입 감시를 사용하여 타입 매개변수를 지정할 수 있습니다:

```java
BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
```

또는 타입 감시를 생략하면 Java 컴파일러는 메서드의 인수를 통해 자동으로 타입 매개변수가 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)라고 추론합니다:

```java
BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
```

 

## Type Inference and Instantiation of Generic Classes

You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (`<>`) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.

For example, consider the following variable declaration:

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
```

You can substitute the parameterized type of the constructor with an empty set of type parameters (`<>`):

```java
Map<String, List<String>> myMap = new HashMap<>();
```

Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the [`HashMap()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/HashMap.html#%3Cinit%3E()) constructor refers to the [`HashMap`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/HashMap.html) raw type, not the `Map<String, List<String>>` type:

```java
Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning
```

 

## Type Inference and Generic Constructors of Generic and Non-Generic Classes

Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:

```java
class MyClass<X> {
  <T> MyClass(T t) {
    // ...
  }
}
```

Consider the following instantiation of the class `MyClass`:

```java
new MyClass<Integer>("")
```

This statement creates an instance of the parameterized type `MyClass<Integer>;` the statement explicitly specifies the type [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) for the formal type parameter, `X`, of the generic `class MyClass<X>`. Note that the constructor for this generic class contains a formal type parameter, `T`. The compiler infers the type [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html) for the formal type parameter, `T`, of the constructor of this generic class (because the actual parameter of this constructor is a [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html) object).

Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (`<>`). Consider the following example:

```java
MyClass<Integer> myObject = new MyClass<>("");
```

In this example, the compiler infers the type [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) for the formal type parameter, `X`, of the generic class `MyClass<X>`. It infers the type [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html) for the formal type parameter, `T`, of the constructor of this generic class.

> Note: It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.

 

## Target Types

The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. The target type of an expression is the data type that the Java compiler expects depending on where the expression appears. Consider the method [`Collections.emptyList()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collections.html#emptyList()), which is declared as follows:

```java
static <T> List<T> emptyList();
```

Consider the following assignment statement:

```java
List<String> listOne = Collections.emptyList();
```

This statement is expecting an instance of `List<String>` this data type is the target type. Because the method [`emptyList()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collections.html#emptyList()) returns a value of type `List<T>`, the compiler infers that the type argument `T` must be the value [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html). This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of `T` as follows:

```java
List<String> listOne = Collections.<String>emptyList();
```

However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:

```java
void processStringList(List<String> stringList) {
    // process stringList
}
```

Suppose you want to invoke the method `processStringList()` with an empty list. In Java SE 7, the following statement does not compile:

```java
processStringList(Collections.emptyList());
```

The Java SE 7 compiler generates an error message similar to the following:

```shell
List<Object> cannot be converted to List<String>
```

The compiler requires a value for the type argument `T` so it starts with the value [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html). Consequently, the invocation of [`Collections.emptyList()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collections.html#emptyList()) returns a value of type `List<Object>`, which is incompatible with the method `processStringList()`. Thus, in Java SE 7, you must specify the value of the type argument as follows:

```java
processStringList(Collections.<String>emptyList());
```

This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method `processStringList()`. In this case, `processStringList()` requires an argument of type `List<String>`. The method [`Collections.emptyList()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collections.html#emptyList()) returns a value of `List<T>`, so using the target type of `List<String>`, the compiler infers that the type argument `T` has a value of [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html). Thus, in Java SE 8, the following statement compiles:

```java
processStringList(Collections.emptyList());
```

 

## Target Typing in Lambda Expressions

Suppose you have the following methods:

```java
public static void printPersons(List<Person> roster, CheckPerson tester)
```

and

```java
public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) 
```

You then write the following code to call these methods:

```java
printPersons(
        people, 
        p -> p.getGender() == Person.Sex.MALE
            && p.getAge() >= 18
            && p.getAge() <= 25);
```

and

```java
printPersonsWithPredicate(
        people,
        p -> p.getGender() == Person.Sex.MALE
             && p.getAge() >= 18
             && p.getAge() <= 25);)
```

How do you determine the type of the lambda expression in these cases?

When the Java runtime invokes the method `printPersons()`, it is expecting a data type of `CheckPerson`, so the lambda expression is of this type. However, when the Java runtime invokes the method `printPersonsWithPredicate()`, it is expecting a data type of [`Predicate<Person>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/function/Predicate.html), so the lambda expression is of this type. The data type that these methods expect is called the target type. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:

- Variable declarations
- Assignments
- Return statements
- Array initializers
- Method or constructor arguments
- Lambda expression bodies
- Conditional expressions, `?:`
- Cast expressions

 

## Target Types and Method Arguments

For method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.

Consider the following two functional interfaces ([`java.lang.Runnable`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runnable.html) and [`java.util.concurrent.Callable<V>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/Callable.html):

```java
public interface Runnable {
    void run();
}

public interface Callable<V> {
    V call();
}
```

The method [`Runnable.run()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runnable.html#run()) does not return a value, whereas [`Callable<V>.call()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/concurrent/Callable.html#call()) does.

Suppose that you have overloaded the method invoke as follows (see the section [Defining Methods](https://dev.java/learn/classes-objects/defining-methods/) for more information about overloading methods):

```java
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}
```

Which method will be invoked in the following statement?

```java
String s = invoke(() -> "done");
```

The method `invoke(Callable<T>)` will be invoked because that method returns a value; the method `invoke(Runnable)` does not. In this case, the type of the lambda expression `() -> "done"` is `Callable<T>`.

---
Last update: September 14, 2021