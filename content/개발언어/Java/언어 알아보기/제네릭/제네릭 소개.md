## 왜 제네릭을 사용하나요?

간단히 말해, 제네릭은 클래스, 인터페이스 및 메서드를 정의할 때 타입(클래스 및 인터페이스)을 매개변수로 사용할 수 있게 해줍니다. 메서드 선언에 사용되는 보다 친숙한 형식 매개변수와 마찬가지로 타입 매개변수는 동일한 코드를 다른 입력으로 재사용할 수 있는 방법을 제공합니다. 형식 매개변수에 대한 입력은 값이고 타입 매개변수에 대한 입력은 타입이라는 차이점이 있습니다.

제네릭을 사용하는 코드는 제네릭이 아닌 코드에 비해 많은 이점이 있습니다:

- 컴파일 시 더 강력한 타입 검사. Java 컴파일러는 제네릭 코드에 강력한 타입 검사를 적용하고 코드가 타입 안전을 위반하는 경우 오류를 발생시킵니다. 컴파일 타임 오류를 수정하는 것은 찾기 어려운 런타임 오류를 수정하는 것보다 쉽습니다.
    
- 형 변환 제거. 제네릭이 없는 다음 코드 스니펫은 형 변환이 필요합니다:
    

```java
List list = new ArrayList();
list.add("hello");
String s = (String) list.get(0);
```

제네릭을 사용하도록 코드를 다시 작성하면 형변환이 필요하지 않습니다:

```java
List<String> list = new ArrayList<String>();
list.add("hello");
String s = list.get(0);   // no cast
```

- 프로그래머가 일반 알고리즘을 구현할 수 있도록 지원합니다. 프로그래머는 제네릭을 사용하여 다양한 유형의 컬렉션에서 작동하고, 사용자 정의할 수 있으며, 타입이 안전하고 읽기 쉬운 제네릭 알고리즘을 구현할 수 있습니다.

 

## 제네릭 타입

### 간단한 Box 클래스

제네릭 타입은 타입에 대해 매개변수화된 제네릭 클래스 또는 인터페이스입니다. 다음 `Box` 클래스를 수정하여 개념을 설명하겠습니다.

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

이 메서드는 [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html)를 받거나 반환하므로 기본 타입이 아니라면 원하는 것은 무엇이든 자유롭게 전달할 수 있습니다. 컴파일 시 클래스가 어떻게 사용되는지 확인할 수 있는 방법은 없습니다. 코드의 한 부분은 Box에 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)를 넣고 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) 타입의 객체를 가져올 것으로 기대하지만, 다른 부분은 실수로 [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html)을 전달하여 런타임 오류가 발생할 수 있습니다.

### Box 클래스의 Generic 버전

_generic 클래스_ 는 다음 형식으로 정의됩니다:

```java
class name<T1, T2, ..., Tn> { /* ... */ }
```

꺾쇠 괄호(`<>`)로 구분된 타입 매개변수 섹션은 클래스 이름 뒤에옵니다. 타입 매개변수(타입 변수라고도 함) `T1`, `T2`, ... 및 `Tn`을 지정합니다.

`Box` 클래스에 제네릭을 사용하도록 업데이트하려면 "`public class Box`"를 "`public class Box<T>`"로 변경하여 제네릭 타입 선언을 생성합니다. 이렇게 하면 클래스 내부 어디에서나 사용할 수 있는 타입 변수 `T`가 도입됩니다.

이렇게 변경하면 `Box` 클래스가 됩니다:

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

보시다시피, [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html)의 모든 항목은 `T`로 대체됩니다. 타입 변수는 클래스 타입, 인터페이스 타입, 배열 타입 또는 다른 타입 변수 등 사용자가 지정한 모든 비 원시 타입이 될 수 있습니다.

일반 인터페이스를 만드는 데에도 동일한 기법을 적용할 수 있습니다.

### 타입 매개변수 명명 규칙

규칙에 따라 타입 매개변수 이름은 대문자로 된 단일 문자입니다. 이는 여러분이 이미 알고 있는 변수 명명 규칙과는 완전히 대조적인데, 이 규칙이 없으면 타입 변수와 일반 클래스 또는 인터페이스 이름을 구분하기 어렵기 때문입니다.

가장 일반적으로 사용되는 타입 매개변수 이름은 다음과 같습니다:

- E - Element (자바 컬렉션 프레임워크에서 광범위하게 사용됩니다.)
    
- K - Key
    
- N - Number
    
- T - Type
    
- V - Value
    
- S, U, V etc. - 2nd, 3rd, 4th types
    
- 이 이름은 Java SE API와 이 섹션의 나머지 부분 전체에서 사용됩니다.
    

### 제네릭 타입 호출 및 인스턴스화하기

코드 내에서 제네릭 `Box` 클래스를 참조하려면 `T`를 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)와 같은 구체적인 값으로 대체하는 제네릭 타입 호출을 수행해야 합니다:

```java
Box<Integer> integerBox;
```

제네릭 타입 호출은 일반적인 메서드 호출과 비슷하다고 생각할 수 있지만, 메서드에 인수를 전달하는 대신 타입 인자(이 경우 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)를) `Box` 클래스 자체에 전달합니다.

> _타입 매개변수와 타입 인자 용어_: 많은 개발자가 "타입 매개변수"와 "타입 인자"라는 용어를 혼용하여 사용하지만 이 용어는 동일하지 않습니다. 코딩할 때 매개변수화된 타입을 생성하기 위해 타입 인수를 제공합니다. 따라서 `Foo<T>`의 `T`는 타입 매개변수이고 `Foo<String> f`의 [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html)은 타입 인자입니다. 이 섹션에서는 이러한 용어를 사용할 때 이 정의를 준수합니다.

다른 변수 선언과 마찬가지로 이 코드는 실제로 새로운 `Box` 객체를 생성하지 않습니다. 단순히 `integerBox`가 "정수의 Box"에 대한 참조를 보유할 것이라고 선언하며, 이것이 `Box<Integer>`가 읽히는 방식입니다.

제네릭 타입의 호출을 일반적으로 매개변수화된 타입이라고 합니다.

이 클래스를 인스턴스화하려면 평소처럼 `new` 키워드를 사용하되, 클래스 이름과 괄호 사이에 `<Integer>`를 넣습니다:

```java
Box<Integer> integerBox = new Box<Integer>();
```

### 다이아몬드

Java SE 7 이상에서는 컴파일러가 컨텍스트에서 타입 인수를 확인하거나 유추할 수 있는 한 제네릭 클래스의 생성자를 호출하는 데 필요한 타입 인수를 빈 타입 인수 집합(`<>`)으로 대체할 수 있습니다. 이 꺾쇠 괄호 쌍인 `<>`를 비공식적으로 다이아몬드라고 부릅니다. 예를 들어, 다음 문으로 `Box<Integer>`의 인스턴스를 만들 수 있습니다:

```java
Box<Integer> integerBox = new Box<>();
```

다이아몬드 표기법 및 타입 추론에 대한 자세한 내용은 이 튜토리얼의 타입 추론 섹션을 참조하세요.

### 다중 타입 매개변수

앞서 언급했듯이 제네릭 클래스는 여러 타입 매개변수를 가질 수 있습니다. 예를 들어 제네릭 `Pair` 인터페이스를 구현하는 제네릭 `OrderedPair` 클래스를 들 수 있습니다:

```java
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
    this.key = key;
    this.value = value;
    }

    public K getKey()    { return key; }
    public V getValue() { return value; }
}
```

다음 문은 `OrderedPair` 클래스의 인스턴스 두 개를 생성합니다:

```java
Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");
```

`new OrderedPair<String, Integer>()` 코드는 `K`를 [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html)으로, `V`를 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)로 인스턴스화합니다. 따라서 `OrderedPair`의 생성자 매개변수 타입은 각각 [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html)과 [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)입니다. 오토박싱으로 인해 클래스에 [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html)과 `int`를 전달하는 것이 유효합니다.

다이아몬드 섹션에서 언급했듯이 Java 컴파일러는 `OrderedPair<String, Integer>` 선언에서 `K` 및 `V` 타입을 유추할 수 있으므로 이러한 문은 다이아몬드 표기법을 사용하여 단축할 수 있습니다:

```java
OrderedPair<String, Integer> p1 = new OrderedPair<>("Even", 8);
OrderedPair<String, String>  p2 = new OrderedPair<>("hello", "world");
```

제네릭 인터페이스를 만들려면 제네릭 클래스를 만들 때와 동일한 규칙을 따르세요.

### 매개변수화된 타입

타입 매개변수(예: `K` 또는 `V`)를 매개변수화된 타입, 즉 [`List<String>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/List.html)으로 대체할 수도 있습니다. 예를 들어 `OrderedPair<K, V>` 예제를 사용합니다:

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));
```

 

## Raw Types

_Raw Types_ 은 타입 인자가 없는 제네릭 클래스 또는 인터페이스의 이름입니다. 예를 들어 제네릭 `Box` 클래스가 있다고 가정해 보겠습니다:

```java
public class Box<T> {
    public void set(T t) { /* ... */ }
    // ...
}
```

`Box<T>`의 매개변수화된 타입을 생성하려면 형식적 타입 매개변수 `T`에 실제 타입 인수를 지정합니다:

```java
Box<Integer> intBox = new Box<>();
```

실제 타입 인자가 생략된 경우, `Box<T>`의 원시 타입을 생성합니다:

```java
Box rawBox = new Box();
```

따라서 `Box`는 제네릭 타입 `Box<T>`의 원시 타입입니다. 그러나 제네릭이 아닌 클래스나 인터페이스 타입은 Raw types이 아닙니다.

Raw types이 레거시 코드에 나타나는 이유는 JDK 5.0 이전에는 많은 API 클래스(예: Collections 클래스)가 제네릭이 아니었기 때문입니다. Raw types을 사용하면 기본적으로 사전 제네릭 동작이 발생하며, Box는 객체를 제공합니다. 이전 버전과의 호환성을 위해 매개변수화된 타입을 Raw types에 할당하는 것은 허용됩니다:

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;               // OK
```

그러나 매개변수화된 타입에 Raw type을 할당하면 경고가 표시됩니다:

```java
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
```

Raw type을 사용하여 해당 제네릭 타입에 정의된 제네릭 메서드를 호출하는 경우에도 경고가 표시됩니다:

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```

이 경고는 Raw type이 제네릭 타입 검사를 우회하여 안전하지 않은 코드의 포착을 런타임으로 연기한다는 것을 보여줍니다. 따라서 Raw type을 사용하지 않아야 합니다.

Java 컴파일러가 Raw type을 사용하는 방법에 대한 자세한 내용은 타입 삭제 섹션을 참조하세요.

### 확인되지 않은 오류 메시지

앞서 언급했듯이 레거시 코드와 제네릭 코드를 혼합할 때 다음과 유사한 경고 메시지가 표시될 수 있습니다:

```shell
Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

다음 예시와 같이 Raw type에서 작동하는 이전 API를 사용할 때 이러한 문제가 발생할 수 있습니다:

```java
public class WarningDemo {
    public static void main(String[] args){
        Box<Integer> bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();
    }
}
```

"unchecked"라는 용어는 컴파일러가 타입 안전을 보장하는 데 필요한 모든 타입 검사를 수행하기에 충분한 타입 정보를 가지고 있지 않음을 의미합니다. 컴파일러에서 힌트를 제공하지만 기본적으로 "unchecked" 경고는 비활성화되어 있습니다. 모든 "unchecked" 경고를 보려면 `-Xlint:unchecked`로 다시 컴파일하세요.

이전 예제를 `-Xlint:unchecked`로 다시 컴파일하면 다음과 같은 추가 정보가 표시됩니다:

```shell
WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box<java.lang.Integer>
        bi = createBox();
                      ^
1 warning
```

체크되지 않은 경고를 완전히 비활성화하려면 `-Xlint:-unchecked` 플래그를 사용합니다. [`@SuppressWarnings("unchecked")`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/SuppressWarnings.html) 어노테이션은 체크되지 않은 경고를 비활성화합니다. [`@SuppressWarnings`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/SuppressWarnings.html) 구문에 익숙하지 않은 경우 어노테이션 섹션을 참조하세요.

 

## 제네릭 메서드

_제네릭 메서드_ 는 자체 타입 매개변수를 도입하는 메서드입니다. 제네릭 타입을 선언하는 것과 비슷하지만 타입 매개변수의 범위가 선언된 메서드로 제한됩니다. 정적 및 비정적 제네릭 메서드는 물론 제네릭 클래스 생성자도 허용됩니다.

제네릭 메서드의 구문에는 메서드의 반환 타입 앞에 나타나는 꺾쇠 괄호 안에 타입 매개변수 목록이 포함됩니다. 정적 제네릭 메서드의 경우, 타입 매개변수 섹션은 메서드의 반환 타입 앞에 나타나야 합니다.

`Util` 클래스에는 두 개의 `Pair` 객체를 비교하는 제네릭 메서드인 compare가 포함되어 있습니다:

```java
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

public class Pair<K, V> {

    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}
```

The complete syntax for invoking this method would be:

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
```

The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
```

This feature, known as type inference, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, Type Inference.

 

## Bounded Type Parameters

There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html) or its subclasses. This is what bounded type parameters are for.

To declare a bounded type parameter, list the type parameter's name, followed by the `extends` keyword, followed by its upper bound, which in this example is [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html). Note that, in this context, `extends` is used in a general sense to mean either "`extends`" (as in classes) or "`implements`" (as in interfaces).

```java
public class Box<T> {

    private T t;          

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public <U extends Number> void inspect(U u){
        System.out.println("T: " + t.getClass().getName());
        System.out.println("U: " + u.getClass().getName());
    }

    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<Integer>();
        integerBox.set(new Integer(10));
        integerBox.inspect("some text"); // error: this is still String!
    }
}
```

By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a [`String`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/String.html):

```shell
Box.java:21: <U>inspect(U) in Box<java.lang.Integer> cannot
  be applied to (java.lang.String)
                        integerBox.inspect("10");
                                  ^
1 error
```

In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:

```java
public class NaturalNumber<T extends Integer> {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;
    }

    // ...
}
```

The `isEven()` method invokes the [`intValue()`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html#intValue()) method defined in the Integer class through `n`.

### Multiple Bounds

The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have multiple bounds:

```java
<T extends B1 & B2 & B3>
```

A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:

```java
Class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
```

If bound `A` is not specified first, you get a compile-time error:

```java
class D <T extends B & A & C> { /* ... */ }  // compile-time error
```

 

## Generic Methods and Bounded Type Parameters

Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array `T[]` that are greater than a specified element `elem`.

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error
            ++count;
    return count;
}
```

The implementation of the method is straightforward, but it does not compile because the greater than operator (`>`) applies only to primitive types such as `short`, `int`, `double`, `long`, `float`, `byte`, and `char`. You cannot use the `>` operator to compare objects. To fix the problem, use a type parameter bounded by the [`Comparable<T>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Comparable.html) interface:

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

The resulting code will be:

```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```

 

## Generics, Inheritance, and Subtypes

As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) to an [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html), since [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html) is one of [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html)'s supertypes:

```java
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
```

In object-oriented terminology, this is called an "is a" relationship. Since an [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) is a kind of Object, the assignment is allowed. But [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) is also a kind of [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html), so the following code is valid as well:

```java
public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
```

The same is also true with generics. You can perform a generic type invocation, passing [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html) as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html):

```java
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
```

Now consider the following method:

```java
public void boxTest(Box<Number> n) { /* ... */ }
```

What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is `Box<Number>`. But what does that mean? Are you allowed to pass in `Box<Integer>` or `Box<Double>`, as you might expect? The answer is "no", because `Box<Integer>` and `Box<Double>` are not subtypes of `Box<Number>`.

This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn. `Box<Integer>` is not a subtype of `Box<Number>` even though [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html) is a subtype of [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html).

![Subtyping parameterized types](https://dev.java/assets/images/generics/01_generics-inheritance.png)

Subtyping parameterized types.

> Note: Given two concrete types `A` and `B`, for example, [`Number`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Number.html) and [`Integer`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Integer.html), `MyClass<A>` has no relationship to `MyClass<B>`, regardless of whether or not `A` and `B` are related. The common parent of `MyClass<A>` and `MyClass<B>` is [`Object`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html).

For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see the section [Wildcards and Subtyping](https://dev.java/learn/generics/wildcards/).

### Generic Classes and Subtyping

You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.

Using the Collections classes as an example, [`ArrayList<E>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/ArrayList.html) implements [`List<E>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/List.html), and [`List<E>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/List.html) extends [`Collection<E>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collection.html). So [`ArrayList<String>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/ArrayList.html) is a subtype of [`List<String>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/List.html), which is a subtype of [`Collection<String>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Collection.html). So long as you do not vary the type argument, the subtyping relationship is preserved between the types.

![A sample Collection hierarchy](https://dev.java/assets/images/generics/02_collections-inheritance.png)

A sample Collection hierarchy.

Now imagine we want to define our own list interface, `PayloadList`, that associates an optional value of generic type `P` with each element. Its declaration might look like:

```java
interface PayloadList<E,P> extends List<E> {
  void setPayload(int index, P val);
  ...
}
```

The following parameterizations of `PayloadList` are subtypes of [`List<String>`](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/List.html):

- `PayloadList<String,String>`
- `PayloadList<String,Integer>`
- `PayloadList<String,Exception>`

![A sample Payload hierarchy](https://dev.java/assets/images/generics/03_more-inheritance.png)

A sample Payload hierarchy.

---
Last update: September 14, 2021