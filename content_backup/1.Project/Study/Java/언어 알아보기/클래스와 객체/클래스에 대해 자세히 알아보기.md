## 클래스에 대한 추가 정보

이 섹션에서는 객체에 대한 이전 섹션에서 배운 객체 참조와 점 연산자 사용에 의존하는 클래스의 더 많은 측면을 다룹니다:

- 메서드에서 값을 반환합니다.
- `this` 키워드.
- 클래스 대 인스턴스 멤버.
- 접근 제어.

 

## 메서드에서 값 return하기

메서드는 메서드를 호출한 코드로 return됩니다.

- 메서드의 모든 명령문을 완료하면 호출한 코드로 return됩니다,
- `return` 문에 도달하거나, 또는
- 예외를 던지거나(나중에 다루겠습니다),
- 먼저 발생하는 것으로 return됩니다.

메서드의 반환 유형은 메서드 선언에서 선언합니다. 메서드 본문에서 `return` 문을 사용하여 값을 반환합니다.

`void`로 선언된 메서드는 값을 반환하지 않습니다. `return` 문을 포함할 필요는 없지만 포함할 수도 있습니다. 이러한 경우 `return` 문을 사용하여 제어 흐름 블록에서 분기하고 메서드를 종료할 수 있으며 다음과 같이 간단히 사용할 수 있습니다:


```java
return;
```

`void`로 선언된 메서드에서 값을 return하려고 하면 컴파일러 오류가 발생합니다.

`void`로 선언되지 않은 모든 메서드에는 다음과 같이 해당 return값이 있는 `return` 문이 포함되어야 합니다:

```java
return returnValue;
```

return 값의 데이터 타입은 메서드의 선언된 반환 타입과 일치해야 하며, `boolean`을 반환하도록 선언된 메서드에서는 정수 값을 반환할 수 없습니다.

객체에 대한 섹션에서 설명한 `Rectangle` 클래스의 `getArea()` 메서드는 정수를 반환합니다:

```java
// a method for computing the area of the rectangle
public int getArea() {
    return width * height;
}
```

이 메서드는 `width*height` 표현식이 평가하는 정수를 반환합니다.

`getArea()` 메서드는 원시 타입을 반환합니다. 메서드는 참조 타입을 반환할 수도 있습니다. 예를 들어 `Bicycle` 객체를 조작하는 프로그램에는 다음과 같은 메서드가 있을 수 있습니다:

```java
public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) {
    Bicycle fastest;
    // code to calculate which bike is 
    // faster, given each bike's gear 
    // and cadence and given the 
    // environment (terrain and wind)
    return fastest;
}
```

 

## 클래스 또는 인터페이스 return하기

이 섹션이 혼란스럽다면 건너뛰고 인터페이스와 상속 섹션을 마친 후에 다시 돌아와서 살펴보세요.

메서드가 `seeWhosFastest()`처럼 클래스 이름을 반환 타입으로 사용하는 경우, 반환되는 객체 타입의 클래스는 반환 타입의 서브클래스이거나 정확한 클래스여야 합니다. 다음 그림과 같이 `ImaginaryNumber`가 `java.lang.Number`의 서브클래스이고, 이는 다시 `Object`의 서브클래스인 클래스 계층 구조가 있다고 가정해 보겠습니다.

![[Pasted image 20240522085339.png]]

`ImaginaryNumber`의 클래스 계층구조

이제 `Number`를 반환하도록 선언된 메서드가 있다고 가정해 봅시다:

```java
public Number returnANumber() {
    ...
}
```

`returnANumber()` 메서드는 `ImaginaryNumber`를 반환할 수 있지만 `Object`는 반환하지 못합니다. `ImaginaryNumber`의 인스턴스도 `Number`의 인스턴스이기 때문에 `ImaginaryNumber`는 `Number`의 서브클래스입니다. 위 설명의 `Object`가 반드시 `Number`일 필요는 없습니다. `String`이나 다른 타입일 수도 있습니다.

다음과 같이 메서드를 재정의하고 원래 메서드의 서브클래스를 반환하도록 정의할 수 있습니다:

```java
public ImaginaryNumber returnANumber() {
    ...
}
```

_covariant return type_ 이라고 하는 이 기술은 return 타입이 서브클래스와 같은 방향으로 변할 수 있다는 것을 의미합니다.

> 참고: 인터페이스를 반환 타입으로 사용할 수도 있습니다. 이 경우 반환되는 객체는 지정된 인터페이스를 구현해야 합니다.

 

## this 키워드 사용

인스턴스 메서드 또는 생성자 내에서, this는 _현재 객체_ 에 대한 참조입니다. — 메서드 또는 생성자가 호출되는 객체입니다. 인스턴스 메서드나 생성자 내에서 `this`를 사용하여 현재 객체의 모든 멤버를 참조할 수 있습니다.

### 필드와 함께 this 사용하기

`this ` 키워드를 사용하는 가장 일반적인 이유는 필드가 메서드 또는 생성자 매개변수에 의해 섀도잉 처리되기 때문입니다.

예를 들어 `Point` 클래스는 다음과 같이 작성되었습니다:

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}
```

이렇게 작성할 수도 있습니다:

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

생성자에 대한 각 인수는 객체의 필드 중 하나를 섀도잉합니다. — 생성자 내부의 `x`는 생성자의 첫 번째 인수의 로컬 복사본입니다. 생성자가 `Point` 필드 `x`를 참조하려면 생성자는 `this.x`를 사용해야 합니다.

### 생성자와 함께 사용하기

생성자 내에서 `this` 키워드를 사용하여 같은 클래스에 있는 다른 생성자를 호출할 수도 있습니다. 이를 명시적 생성자 호출이라고 합니다. 다음은 객체 섹션에 있는 것과는 다른 구현을 가진 또 다른 `Rectangle` 클래스입니다.

```java
public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
```

이 클래스에는 생성자 집합이 포함되어 있습니다. 각 생성자는 사각형의 멤버 변수 중 일부 또는 전부를 초기화합니다. 생성자는 인자로 초기값이 제공되지 않는 멤버 변수에 대해 기본값을 제공합니다. 예를 들어, 인수가 없는 생성자는 좌표 0,0에 1x1 직사각형을 만듭니다. 인자가 두 개인 생성자는 인자가 네 개인 생성자를 호출하여 `width`과 `height`를 전달하지만 항상 0,0 좌표를 사용합니다. 이전과 마찬가지로 컴파일러는 인자의 수와 타입에 따라 어떤 생성자를 호출할지 결정합니다.

다른 생성자가 있는 경우, 다른 생성자의 호출은 생성자의 첫 번째 줄에 있어야 합니다.

 

## 클래스 멤버에 대한 접근 권한 제어하기

액세스 수준 수정자는 다른 클래스가 특정 필드를 사용하거나 특정 메서드를 호출할 수 있는지 여부를 결정합니다. 액세스 제어에는 두 가지 수준이 있습니다:

- 최상위 수준 —`public` 또는 패키지-비공개(명시적 수정자 없음).
- 멤버 수준 — `public`, `private`, `protected` 또는 패키지-비공개(명시적 수정자 없음).

A class may be declared with the modifier `public`, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package (packages are named groups of related classes — you will learn about them in a later section.)

At the member level, you can also use the `public` modifier or no modifier (package-private) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: `private` and `protected`. The `private` modifier specifies that the member can only be accessed in its own class. The `protected` modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.

The following table shows the access to members permitted by each modifier.

|Modifier|Class|Package|Subclass|World|
|---|---|---|---|---|
|`public`|Y|Y|Y|Y|
|`protected`|Y|Y|Y|N|
|_no modifier_|Y|Y|N|N|
|`private`|Y|N|N|N|

The first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members.

The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member.

The third column indicates whether subclasses of the class declared outside this package have access to the member.

The fourth column indicates whether all classes have access to the member.

Access levels affect you in two ways. First, when you use classes that come from another source, such as the classes in the Java platform, access levels determine which members of those classes your own classes can use. Second, when you write a class, you need to decide what access level every member variable and every method in your class should have.

### Tips on Choosing an Access Level:

If other programmers use your class, you want to ensure that errors from misuse cannot happen. Access levels can help you do this.

Use the most restrictive access level that makes sense for a particular member. Use `private` unless you have a good reason not to.

Avoid `public` fields except for constants. Many of the examples in the tutorial use `public` fields. This may help to illustrate some points concisely, but is not recommended for production code. This is not a good practice because `public` fields tend to link you to a particular implementation and limit your flexibility in changing your code.

 

## Understanding Class Members

In this section, we discuss the use of the `static` keyword to create fields and methods that belong to the class, rather than to an instance of the class.

### Class Variables

When a number of objects are created from the same class blueprint, they each have their own distinct copies of instance variables. In the case of the `Bicycle` class, the instance variables are `cadence`, `gear`, and `speed`. Each `Bicycle` object has its own values for these variables, stored in different memory locations.

Sometimes, you want to have variables that are common to all objects. This is accomplished with the `static` modifier. Fields that have the `static` modifier in their declaration are called `static` fields or _class variables_. They are associated with the class, rather than with any object.

Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.

For example, suppose you want to create a number of `Bicycle` objects and assign each a serial number, beginning with 1 for the first object. This `ID` number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many `Bicycle` objects have been created so that you know what `ID` to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, `numberOfBicycles`, as follows:

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    // add an instance variable for the object ID
    private int id;
    
    // add a class variable for the
    // number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
        ...
}
```

Class variables are referenced by the class name itself, as in

```java
Bicycle.numberOfBicycles
```

This makes it clear that they are class variables.

> Note: You can also refer to static fields with an object reference like `myBike.numberOfBicycles` but this is discouraged because it does not make it clear that they are class variables.

You can use the `Bicycle` constructor to set the `ID` instance variable and increment the `numberOfBicycles` class variable:

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    private static int numberOfBicycles = 0;
        
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        // increment number of Bicycles
        // and assign ID number
        id = ++numberOfBicycles;
    }

    // new method to return the ID instance variable
    public int getID() {
        return id;
    }
        ...
}
```

### Class Methods

The Java programming language supports static methods as well as static variables. Static methods, which have the `static` modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in

```java
ClassName.methodName(args)
```

> Note: You can also refer to static methods with an object reference like `instanceName.methodName(args)` but this is discouraged because it does not make it clear that they are class methods.

A common use for static methods is to access static fields. For example, we could add a static method to the `Bicycle` class to access the `numberOfBicycles` static field:

```java
public static int getNumberOfBicycles() {
    return numberOfBicycles;
}
```

Not all combinations of instance and class variables and methods are allowed:

- Instance methods can access instance variables and instance methods directly.
- Instance methods can access class variables and class methods directly.
- Class methods can access class variables and class methods directly.
- Class methods cannot access instance variables or instance methods directly—they must use an object reference. Also, class methods cannot use the `this` keyword as there is no instance for this to refer to.

### Constants

The `static` modifier, in combination with the `final` modifier, is also used to define constants. The `final` modifier indicates that the value of this field cannot change.

For example, the following variable declaration defines a constant named `PI`, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):

```java
static final double PI = 3.141592653589793;
```

Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (`_`).

> Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.

### The Bicycle Class

After all the modifications made in this section, the `Bicycle` class is now:

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    private int id;
    
    private static int numberOfBicycles = 0;

        
    public Bicycle(int startCadence,
                   int startSpeed,
                   int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        id = ++numberOfBicycles;
    }

    public int getID() {
        return id;
    }

    public static int getNumberOfBicycles() {
        return numberOfBicycles;
    }

    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear(){
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
```

 

## Initializing Fields

As you have seen, you can often provide an initial value for a field in its declaration:

```java
public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}
```

This works well when the initialization value is available and the initialization can be put on one line. However, this form of initialization has limitations because of its simplicity. If initialization requires some logic (for example, error handling or a for loop to fill a complex array), simple assignment is inadequate. Instance variables can be initialized in constructors, where error handling or other logic can be used. To provide the same capability for class variables, the Java programming language includes _static initialization blocks_.

> Note: It is not necessary to declare fields at the beginning of the class definition, although this is the most common practice. It is only necessary that they be declared and initialized before they are used.

### Static Initialization Blocks

A static initialization block is a normal block of code enclosed in braces, `{ }`, and preceded by the `static` keyword. Here is an example:

```java
static {
    // whatever code is needed for initialization goes here
}
```

A class can have any number of static initialization blocks, and they can appear anywhere in the class body. The runtime system guarantees that static initialization blocks are called in the order that they appear in the source code.

There is an alternative to static blocks — you can write a private static method:

```java
class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}
```

The advantage of private static methods is that they can be reused later if you need to reinitialize the class variable.

You should be aware that you cannot redefine the content of a static block. Once it has been written, you cannot prevent this block to be executed. If the content of the static block cannot be executed for whatever reason, then your application will not work properly, because you will not be able to instantiate any object for this class. This may happen if your static block contains code that accesses some external resource, like a file system, or a network.

### Initializing Instance Members

Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.

Initializer blocks for instance variables look just like static initializer blocks, but without the static keyword:

```java
{
    // whatever code is needed for initialization goes here
}
```

The Java compiler copies initializer blocks into every constructor. Therefore, this approach can be used to share a block of code between multiple constructors.

A _final method_ cannot be overridden in a subclass. This is discussed in the section on [Inheritance](https://dev.java/learn/numbers-strings/strings/). Here is an example of using a final method for initializing an instance variable:

```java
class Whatever {
    private varType myVar = initializeInstanceVariable();
        
    protected final varType initializeInstanceVariable() {

        // initialization code goes here
    }
}
```

This is especially useful if subclasses might want to reuse the initialization method. The method is final because calling non-final methods during instance initialization can cause problems.

 

## Summary of Creating and Using Classes and Objects

A class declaration names the class and encloses the class body between braces. The class name can be preceded by modifiers. The class body contains fields, methods, and constructors for the class. A class uses fields to contain state information and uses methods to implement behavior. Constructors that initialize a new instance of a class use the name of the class and look like methods without a return type.

You control access to classes and members in the same way: by using an access modifier such as public in their declaration.

You specify a class variable or a class method by using the `static` keyword in the member's declaration. A member that is not declared as `static` is implicitly an instance member. Class variables are shared by all instances of a class and can be accessed through the class name as well as an instance reference. Instances of a class get their own copy of each instance variable, which must be accessed through an instance reference.

You create an object from a class by using the `new` operator and a constructor. The `new` operator returns a reference to the object that was created. You can assign the reference to a variable or use it directly.

Instance variables and methods that are accessible to code outside of the class that they are declared in can be referred to by using a qualified name. The qualified name of an instance variable looks like this:

```java
objectReference.variableName
```

The qualified name of a method looks like this:

```java
objectReference.methodName(argumentList)
```

or:

```java
objectReference.methodName()
```

The garbage collector automatically cleans up unused objects. An object is unused if the program holds no more references to it. You can explicitly drop a reference by setting the variable holding the reference to `null`.

---
Last update: January 5, 2024